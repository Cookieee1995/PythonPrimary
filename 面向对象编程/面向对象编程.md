# 面向对象编程

 要让代码真正称得上是面向对象的，那么对象一般需要参与到所谓的继承层次中。

类是在Python中实现一种新的对象，并支持继承的代码结构和部件。

类是Python面向对象程序设计（OOP）的主要工具。

OOP提供了一种不同寻常而往往更有效的编程方式，利用这种设计方法，我们将代码分解从而把荣誉程度降至最低，并且通过定制已有的代码来编写新的程序而不是在原处进行修改。

在Python中，类的创建使用了一条新的语句：class语句。类就是一些函数的包，这些函数大量地使用并处理内置对象类型。类的设计是为了创建和管理新的对象，同时它们也支持继承。继承是一种代码定制和复用的机制。

## 为何使用类

类就是一种定义新种类的东西的方式，它在程序领域中反映了现实中的对象。

例如，假设现在要实现比萨制作机器人。如果通过类来实现，就可以建立其真实世界中结构和关系的模型。从以下的两方面来看OOP非常有用：

继承

```
比萨机器人本质上是一种机器人，它拥有一般机器人的属性。制作比萨机器人继承了所有机器人的通用类型的属性。
```

组合

```
机器人是一个组合的实例，它包含其他对象，这些对象来完成相应的指令。每个组件都可以写成类，并定义自己的行为以及关系。
```

像继承和组合这样的通用OOP概念，适用于能够分解成一系列对象的任何应用程序。

类是Python程序的组成单元，就像函数和模块一样：类是封装和数据的另一种方式。实际上，类也定义了新的命名空间，这点和模块很像。

多重实例

```
类本质上是产生对象的工厂。每当我们调用一个类的时候，就会产生一个有独立命名空间的新对象。每个由类产生的对象都能读取类的属性，并获得自己的命名空间来储存数据，这些数据是属于每个对象本身的。
```

通过继承进行定制

```
我们可以在类的外部以编写子类的方式，来重新定义其属性进而扩充这个类。
```

运算符重载

```
通过提供特定的协议方法，类可以定义对象来相应在内置类型上的一些运算。
```

从本质上讲，Python中的OOP机制主要依托于两个基础：一个特殊的函数第一位参数以及继承属性搜索。

## 概览OOP

### 属性继承搜索

```
object.attribute
```

该表达式读取模块的属性，调用对象的方法。

当我们对class语句产生的对象使用这种方式时，这个表达式会在Python中启动一次搜索，即搜索对象连接的类树，来寻找attribute首次出现的类。当类参与其中时，上面的Python表达式实际上等同于下列自然语言：

```
找出attribute首次出现的地方，先搜索object，然后是该对象之上的所有类，由下往上，从左到右。
```

属性访问就只是搜索类树而已。我们称这种搜索为继承，因为树中位置较低对象继承了树中位置较高的对象所拥有的属性。

在Python对象模型中，类和通过类产生的实例是两种不同的对象类型：

类

```
类是实例工厂。类的属性提供了行为，所有从类产生的实例都继承该类的属性。
```

实例

```
代表程序领域中具体的元素。实例的属性记录了每个实例自己的数据。
```

实例从它的类继承属性，而类则是从搜索树中所有比它更高的类中继承属性。

### 类和实例

例如，在实际应用中，我们可能会有一个Employee类用于定义所谓的员工。通过这个类，我们可以产生实际的Employee实例。

类和模块还有另一个差异：内存中一个特定模块只有一个实例，但是对类而言，只有需要创建多少实例都可以。从操作的角度来说，类通常都有函数，而实例有其他基本的数据项，类的函数中是用来这些数据。面向对象模型与经典的过程加记录的数据处理模型相比，并没有太多的差异。

在OOP中，实例就像是带有“数据”的记录，而类则是处理这些记录的“程序”。

### 方法调用

Python把隐含额实例传入方法中特殊的第一位参数，习惯上将其称为self。方法通过这个参数来处理调用的主体。

### 编写类树

- 每个class语句会生成一个新的类对象
- 每次类调用时，就会生成一个新的实例对象。
- 实例自动链接到创建它们的类。
- 类链接到其他父类的方式是，将父类列在class头部的括号内；括号中从左至右的属性会决定树中的次序。

```
class C2: ...
class C3: ...
class C1(C2,C3): ...

I1=C1()
I2=C1()
```

我们通过运行三个class语句创建了三个类对象，然后通过把类C1当做函数调用了两次，来创建了两个实例对象。这些实例记住了它们来自哪个类，而类C1也记住了它所列出的父类。

多继承就是类树中的某个类有多于一个的父类。在Python中，如果class语句中的小括号内有一个以上的父类，它们由左至右的次序会决定父类继承搜索的顺序。一个名称列在最左边的版本会被默认使用。

因为继承搜索以这种方式进行，你要把属性附加哪个对象就变得非常重要：这个选择决定了属性名称的作用域。附加在实例上的属性只属于那些实例，但附加在类上的属性则由所有子类和实例共享。

- 属性通常实在class语句的顶层语句块中通过复制语句添加到类中，而不是嵌入在内部的函数def语句中。
- 属性通常是通过对特殊的称为self的第一位参数的赋值，来附加给实例的，而这个self参数也被传入类中编写的方法函数。

类通过方法函数为实例提供行为。因为这样的嵌套def会在类中对名称进行赋值，实际效果就是把属性添加在了类对象之中，从而可以由所有实例和子类继承：

```
class C2: ...
class C3: ...

class C1(C2,C3):
	def setname(self,who):
		self.name = who

I1 = C1()
I2 = C1()
I1.setname('bob')
I1.setname('suel')
print(I1.name)
```

从操作的角度来看，当def出现在类的内部时，通常称为方法，而且会自动接收第一个特殊参数，这个参数提供了被处理的实例的引用。所有你自己向方法中传入的参数都被赋值给了self后面的参数。

### 运算符重载

如果类想确保像name这样的名称一定会在其实李忠设置，通常会在构造时填好这个属性：

```
class C2: ...
class C3: ...

class C1(C2,C3):
	def __init__(self,who):
		self.name = who
		
I1 = C1('bob')
I2 = C1('mel')
print(I1.name)
```

如果已经编写或继承了名为 \_\_init\_\_ 的方法，那么每次从类产生实例时Python都会自动调用 \_\_init\_\_ 方法。新实例会如往常那样传入第一位self参数，而列在类调用小括号内的任何值会成为第二以及其后的参数。其效果就是在创建实例时初始化了这个实例，而不需要额外的方法调用。

\_\_init\_\_ 也称为构造函数。这是所谓的运算符重载方法这一大类方法中常用的代表。

### OOP是关于代码重用

类也可以支持实现自己的操作，例如，索引运算、属性访问和打印等。OOP就是在树中搜索属性和在函数加入一个特殊的第一位参数。

通过类，我们可以定制现有的软件来编写代码，而不是对现有代码进行在远处的修改或者对每个新项目都从头开始。

#### 多态和类

多态是指运算的意义取决于运算的对象。代码不应该关心它处理的对象是什么，而只应当关注这个对象应该做什么。

### 通过定制化编程

